1) При включении (ST_Enable) шаговый двигатель смешается в ближайшее устойчивое положение.
Это положение зачастую абсолютно случайно выбирается, но при этом не превышает -+ 0.5-1 step.

2) После установления в начальное положение шаговый двигатель ведёт себя почти точно.

3) Дело в том, что в драйвере, который я использую A4988, премя реакции на все сигналы, кроме
сигнала STEP: DIR, ENABLE, SLEEP, составляет 200 ns, но stm32 выполняет каждую команду за
(1 / 48 000 000) s ~ 21 ns. Т.е. выполнение двух команд: установить направление (DIR) 
и сделать шаг (STEP) занимает ~50 ns, а разница между сигналами и того меньше в два раза. Т.е.
драйевр не успевает реагировать на изменение DIR и вращает в предыдущем направлении по сигналам STEP,
пока не пройдёт 200 ns, и только потом начинает вращаться в нужную сторону. Отсюда и берутся потери
шагов. Чтобы этого избежать, нужно при изменении направления выжидать минимум 200 ns и только потом
отправлять необходимый сигнал STEP. Для других драйверов времена могут отличаться.

4) Почему-то если перед вызовом LL_TIM_EnableIT_UPDATE не вызвать LL_TIM_ClearFlag_UPDATE, то
сразу вызовится прерывание UPDATE. 

5) Генерирование импульсов с необходимыми параметрами без лишнего импульса в один период можно
добиться в режиме Gen. PWM выключив Output compare preload

6) Чтобы сделать короткий импульс (например, для управления драйвером ШД), после 
конфигурирования в One Pulse Mode (OPM) таймер, включения канала (LL_TIM_CC_EnableChannel),
ARR в нужное значение, а CCR в 0, нужно:

    1) Выключить теневой регистр, чтобы налету изменялись настройки таймера
    LL_TIM_OC_DisablePreload (TIM2, LL_TIM_CHANNEL_CH1);
    
    2) Установить длительность импульса (CCR)
    LL_TIM_OC_SetCompareCH1 (TIM2, 10);
    
    3) Включить теневой регистр, чтобы только после завершения импульса следующие
       натсройки вошли в силу
    LL_TIM_OC_EnablePreload (TIM2, LL_TIM_CHANNEL_CH1);

    5) Утановить в значение по сравнению 0, чтобы после
       собыития UPDATE по переполнению ARR, снова не установился на выходе положительный сигнал
    LL_TIM_OC_SetCompareCH1 (TIM2, 0);

    4) Начать генерацию импульса, включив счётчик
    LL_TIM_EnableCounter (TIM2);

7) Миникостыль с библиотекой для arm-none-eabi-gdb:
   arm-none-eabi-gdb: error while loading shared libraries: libmpfr.so.4